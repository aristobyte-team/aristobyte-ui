export const EN_GB = {
  sidebar: {
    header: { title: "AristoByte UI", subtitle: "Documentation" },
    sections: {
      components: "Component",
      presets: "Presets",
      "get-started": "Get started",
    },
    links: {
      button: "Button",
      card: "Card",
      dropdown: "Dropdown",
      spinner: "Spinner",
      installation: "Installation",
      overview: "Overview",
      "message-box": "Message Box",
      radio: "Radio",
      switch: "Switch",
      "social-media-card": "Social Media Card",
      "music-player": "Music Player",
      "statistics-cards": "Statistics Cards",
      "settings-panel": "Settings Panel",
      "action-buttons": "Action Buttons",
      "status-indicators": "Status Indicators",
      "navigation-pills": "Navigation Pills",
      "quick-actions": "Quick Actions",
      "weather-widget": "Weather Widget",
      "notification-cards": "Notification Cards",
      "todo-list": "Todo List",
      "chat-messages": "Chat Messages",
      "activity-feed": "Activity Feed",
      "shopping-cart": "Shopping Cart",
      "file-upload-area": "File Upload Area",
      "progress-tracker": "Progress Tracker",
      "media-controls": "Media Controls",
      "pricing-card": "Pricing Card",
      "calendar-widget": "Calendar Widget",
      "device-status": "Device Status",
      "analytics-dashboard": "Analytics Dashboard",
      "contact-card": "Contact Card",
      "file-manager": "File Manager",
      "quick-stats": "Quick Stats",
      "mini-menu": "Mini Menu",
      "notification-badges": "Notification Badges",
      "profile-badge": "Profile Badge",
      "time-&-location-widget": "Time & Location Widget",
      "energy-meter": "Energy Meter",
      "cryptocurrency-widget": "Cryptocurrency Widget",
      "gaming-controller-widget": "Gaming Controller Widget",
      "streak-counter": "Streak Counter",
      "layer-stack-widget": "Layer Stack Widget",
      "inspiration-widget": "Inspiration Widget",
      "nature-widget": "Nature Widget",
      "reading-progress": "Reading Progress",
      "idea-bulb-widget": "Idea Bulb Widget",
      "rocket-launch-widget": "Rocket Launch Widget",
      "tool-widget": "Tool Widget",
      "color-palette-widget": "Color Palette Widget",
      "system-status": "System Status",
      "pomodoro-timer": "Pomodoro Timer",
      "database-widget": "Database Widget",
      "network-status": "Network Status",
      "code-stats": "Code Stats",
      "mouse-tracker": "Mouse Tracker",
      "design-system": "Design System",
      "ai-assistant": "AI Assistant",
      "office-building-widget": "Office Building Widget",
      "team-collaboration-widget": "Team Collaboration Widget",
      "health-monitor": "Health Monitor",
      "email-dashboard": "Email Dashboard",
      "document-scanner": "Document Scanner",
      "social-engagement": "Social Engagement",
      "video-call-widget": "Video Call Widget",
      "task-manager": "Task Manager",
      "fitness-tracker": "Fitness Tracker",
      "cloud-storage": "Cloud Storage",
      "language-learning": "Language Learning",
      "stock-market": "Stock Market",
      "recipe-finder": "Recipe Finder",
      "travel-planner": "Travel Planner",
      "budget-tracker": "Budget Tracker",
      "password-manager": "Password Manager",
      "photo-editor": "Photo Editor",
      "music-production": "Music Production",
      "shopping-list": "Shopping List",
      "habit-tracker": "Habit Tracker",
      "code-editor": "Code Editor",
    },
    footer: {
      title: "AristoByte Team",
      subtitle: "v{{version}} • © 2025",
    },
  },
  layout: {
    labels: {
      "design-system-component": "Design System Component",
      required: "Required",
      es6Modules: "ES6 Modules",
      core: "Core",
      typescript: "Typescript",
    },
    "intro-links": {
      source: "Source",
    },
    "import-tabs": {
      individual: "Individual",
      global: "Global",
    },
    codePreview: {
      code: "Code",
      preview: "Preview",
    },
    commonTitles: {
      installation: "Installation",
      import: "Import",
      individualPackage: "Individual Package",
      fullLibrary: "Full Library",
      globalLibrary: "Global Library",
      packageManager: "Package Manager",
      importMethod: "Import Method",
      usage: "Basic Usage Example",
      guideline: "{{section}} Guideline",
      props: {
        main: "Props Reference",
        "core-props": "Core Props",
        "state-props": "State Props",
        "visual-props": "Visual Props",
        "advanced-props": "Advanced Props",
        default: "default: {{value}}",
      },
    },
    commonDescriptions: {
      usage:
        "Basic implementation of the component using default properties. Suitable for general-purpose interactions.",
      installation:
        "Install the <b>{{package}}</b> individually or as part of the complete <b>@aristobyte-ui</b> library.",
      installationIndividualPackage:
        "Install only the <b>{{package}}</b> if you need specific functionality.",
      installationFullLibrary:
        "Skip this if you have the complete <b>@aristobyte-ui</b> already installed.",
      import:
        "Choose between individual package imports or global library imports based on your project's needs and bundle size requirements.",
      importIndividualPackage:
        "Import directly from the <b>{{package}}</b> package for optimal tree-shaking and smaller bundle sizes.",
      importIndividualPackageAltText:
        "Recommended for component-specific usage",
      importGlobalLibrary:
        "Import from the main library package when using multiple components from <b>AristoByte UI.</b>",
      importGlobalLibraryAltText: "Recommended for component-specific usage",
      props:
        "Complete reference for all props available on {{components}} component(s), including type definitions, default values, and usage examples.",
    },
    "get-started": {
      overview: {
        intro: {
          title: "AristoByte UI - A Scalable, Design-Driven Component System",
          description:
            "AristoByte UI is a forward-thinking component library engineered for performance, consistency, and maintainability. Built with TypeScript and SCSS, it empowers developers to rapidly build modern UIs with a clean architecture, reusable patterns, and first-class DX across web and mobile platforms.",
        },
        installation: {
          title: "Install AristoByte UI - Get Started in Seconds",
          description:
            "Seamlessly integrate AristoByte UI into your project using your preferred package manager. Whether you use Yarn, npm, or pnpm, installation is straightforward and fast. Choose your tooling tab below and run the command to unlock a powerful, modular component system optimized for scale.",
        },
        import: {
          title: "Import",
          description:
            "Each component in the AristoByte UI library is designed for seamless integration, offering clean abstractions and consistent styling across your application. To start using any component, simply import it directly from the package entry point. This approach ensures modularity and eliminates unnecessary bundle weight while maintaining a standardized development experience.",
        },
      },
    },
    components: {
      button: {
        intro: {
          title: "Button",
          description:
            "The Button component is a fundamental interactive element designed to trigger actions and provide clear visual feedback. It supports multiple variants, sizes, and states to match various UI requirements.",
        },
        installation: {
          title: "Installation of Button",
          description:
            "The above command is for individual installation of Button only. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Button",
          description:
            "The Button component is a core interactive element in the AristoByte UI library, offering a consistent and accessible way to trigger actions. It supports multiple variants and states to align with your brand and interaction patterns. Import it as shown below to streamline call-to-action elements across your application:",
        },
        disabled: {
          title: "Disabled State",
          description:
            "Use the <b>disabled</b> prop to visually and functionally disable buttons, preventing user interaction when needed.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Usage Scenarios",
            list1: {
              element1:
                "Gate actions during async processing or unmet prerequisites.",
              element2:
                "Prevent destructive ops when user lacks authorization.",
              element3:
                "Disable during automatic retries or pending network reconciliation to avoid duplicate side-effects.",
              element4:
                "Conditionally disable when dependent form fields are invalid or validation is in-flight.",
            },
            subtitle2: "Developer Tips",
            list2: {
              element1:
                "Pair with tooltip or helper text to explain why it's disabled.",
              element2:
                "Maintain focus order; use aria-disabled for non-native buttons.",
              element3:
                "Expose semantic attributes (data-disable-reason) for telemetry and test automation.",
              element4:
                "Ensure disabled visuals are covered by unit/integration tests to prevent regressions.",
            },
          },
        },
        sizes: {
          title: "Button Sizes",
          description:
            "The Button component supports multiple size variants to match various UI needs, from compact to full-scale buttons.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Design Considerations",
            list1: {
              element1: "Use smaller sizes for dense toolbars and compact UIs.",
              element2:
                "Use larger sizes for primary CTAs and mobile ergonomics.",
              element3:
                "Prefer consistent padding tokens across sizes to maintain rhythm across components.",
              element4:
                "Scale icons and spinner assets proportionally when changing <b>size</b> to avoid visual imbalance.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Keep size consistent within the same context/surface.",
              element2:
                "Respect minimum hit area (~44×44px) for touch targets.",
              element3:
                "Provide clear size mapping in component docs so consumers can programmatically choose sizes.",
              element4:
                "Avoid hard-coded font sizes inside buttons; derive from typography tokens for theme compliance.",
            },
          },
        },
        radius: {
          title: "Border Radius",
          description:
            "Control the corner radius of buttons using predefined shape tokens or custom values for seamless UI integration.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Visual Guidance",
            list1: {
              element1: "Align radius with product-wide shape semantics.",
              element2: "Use sharper corners for enterprise-dense layouts.",
              element3:
                "Use tokenized radius values to preserve cross-component consistency.",
              element4:
                "Consider platform affordances (iOS vs Android metaphors) when choosing extreme radii for mobile surfaces.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Avoid mixing multiple radii in one action cluster.",
              element2:
                "Maintain consistent radius across button + dropdown combos.",
              element3:
                "When theming, provide a clear override strategy to prevent accidental radius fragmentation.",
              element4:
                "Verify radius rendering at scale with visual regression snapshots to catch clipping issues.",
            },
          },
        },
        colors: {
          title: "Color Themes",
          description:
            "Buttons support multiple color schemes mapped to your design tokens. Ideal for conveying intent and context.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Apply",
            list1: {
              element1:
                "Map semantic actions to tokenized variants (e.g., success).",
              element2:
                "Reserve brand-primary for the single most important CTA.",
              element3:
                "Use neutral/ghost colors for low-impact utilities to reduce visual noise.",
              element4:
                "Align variant palettes with accessibility contrast checks during theme builds.",
            },
            subtitle2: "Accessibility Notes",
            list2: {
              element1: "Ensure contrast ratios meet AA minimums.",
              element2: "Avoid using red for non-destructive actions.",
              element3:
                "Test color variants under different user themes (dark/light/high-contrast).",
              element4:
                "Document fallback color behavior for brand tokens that may not exist in consumer themes.",
            },
          },
        },
        variants: {
          title: "Button Variants",
          description:
            "Buttons can adopt different colors (e.g., <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>warning</b>, <b>error</b>) to reflect status or brand semantics during loading phases.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Interaction Patterns",
            list1: {
              element1: "Primary for highest-priority, single action per view.",
              element2: "Secondary/tertiary for less prominent alternatives.",
              element3:
                "Use neutral variants for contextual actions that should not compete visually with CTAs.",
              element4:
                "Reserve <b>error</b> and <b>warning</b> variants for flows that require explicit user acknowledgement.",
            },
            subtitle2: "Operational Guidelines",
            list2: {
              element1: "Do not stack multiple primaries together.",
              element2:
                "Use destructive (error) variant only for irreversible ops.",
              element3:
                "Instrument variant usage to track UX patterns and detect misuse across large apps.",
              element4:
                "Provide clear migration notes when changing the default variant mapping in a major release.",
            },
          },
        },
        appearance: {
          title: "Button Appearance",
          description:
            "The <b>appearance</b> prop defines the visual style of the button surface. Choose between <b>solid</b>, <b>outline</b>, <b>outline-dashed</b>, <b>no-outline</b>, and <b>glowing</b> to adapt to different UI contexts. While <b>variant</b> conveys semantic intent (e.g., primary, success), <b>appearance</b> controls the decorative rendering layer. This allows you to decouple behavior from style and maintain a more flexible component structure.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Design Considerations",
            list1: {
              element1:
                "Use solid for CTAs; outline for secondary/inverse surfaces.",
              element2: "Use dashed/ghost patterns for low-emphasis utilities.",
              element3:
                "Prefer <b>no-outline</b> when embedding buttons into dense UI panels to minimize stroke noise.",
              element4:
                "Use glowing sparingly and reserve for micro-interactions or marketing surfaces only.",
            },
            subtitle2: "Performance & Behavior",
            list2: {
              element1: "Avoid glowing for critical or enterprise contexts.",
              element2: "Maintain sufficient hit affordance with no-outline.",
              element3:
                "Avoid heavy box-shadow/glow on many elements simultaneously to keep paint budgets reasonable.",
              element4:
                "Provide CSS-only fallbacks for appearance options to support environments without full JS hydration.",
            },
          },
        },
        loading: {
          title: "Loading State",
          description:
            "The <b>isLoading</b> state provides feedback during asynchronous operations. It disables interaction and shows a spinner.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Apply",
            list1: {
              element1: "Apply for async tasks expected to exceed ~500ms.",
              element2:
                "Lock repetitive triggers to prevent duplicate requests.",
              element3:
                "Use loading states for multi-step workflows where intermediate state persists across screens.",
              element4:
                "Prefer inline loaders rather than full-overlay loaders for non-blocking operations.",
            },
            subtitle2: "Continuity & UX",
            list2: {
              element1:
                "Swap label to progress-friendly copy (e.g., “Saving…”).",
              element2:
                "Restore focus to the button on completion for continuity.",
              element3:
                "Provide ARIA live updates where appropriate to announce completion to assistive tech.",
              element4:
                "Ensure spinner animation is paused or simplified in low-power modes.",
            },
          },
        },
        "with-icon": {
          title: "Buttons with Icon",
          description:
            "Pass an icon component via the <b>icon.component</b> prop and choose its position with <b>icon.align</b>. Icons support both <b>left</b> and <b>right</b> alignment and can be used alongside a loading spinner. To render an <b>icon-only</b> button, simply omit the children.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Visual Guidance",
            list1: {
              element1: "Use icons to reinforce meaning, not replace labels.",
              element2:
                "Icon-only buttons require accessible labels (aria-label).",
              element3:
                "Prefer a single icon library for consistency in stroke/weight across the UI.",
              element4:
                "Align icon metrics to text baseline to avoid optical misalignment in mixed-size buttons.",
            },
            subtitle2: "Accessibility & Implementation",
            list2: {
              element1: "Keep icon size aligned with text height.",
              element2: "Ensure consistent spacing between icon and label.",
              element3:
                "Provide accessible name via aria-label when children are omitted.",
              element4:
                "Avoid animating icon layout shifts during label/content changes to prevent reflow.",
            },
          },
        },
        "button-group": {
          title: "Button Group",
          description:
            "Group multiple <b>Button</b> components into a single logical unit with shared styling and configuration. Use <b>ButtonGroup</b> to automatically propagate common props like <b>variant</b> and <b>size</b> across all children. Only <b>Button</b> elements are accepted as valid children, ensuring consistency and preventing unintended usage.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Usage Scenarios",
            list1: {
              element1: "Cluster mutually related actions (e.g., formatting).",
              element2: "Use for mode-switching or segmented controls.",
              element3:
                "Apply for quick-action rows where grouping reduces cognitive load.",
              element4:
                "Use grouped buttons for responsive toolbars that collapse into menus on narrow viewports.",
            },
            subtitle2: "Interaction Patterns",
            list2: {
              element1: "Preserve logical order and consistent sizes.",
              element2: "Support arrow-key navigation for accessibility.",
              element3:
                "Ensure focus ring and selected-state visuals are propagated consistently.",
              element4:
                "Do not mix unrelated actions inside a single group; prefer contextual separation.",
            },
          },
        },
        "button-group-disabled": {
          title: "Disabled Button Group",
          description:
            "Apply the <b>disabled</b> prop on the <b>ButtonGroup</b> component to disable all nested buttons in a unified manner. This ensures consistent visual feedback and prevents individual interaction without modifying each button separately.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Scenarios",
            list1: {
              element1:
                "Disable an entire cluster when upstream state blocks all.",
              element2:
                "Use to prevent partial interaction in multi-step flows.",
              element3:
                "Use group-level disabling for transactional flows awaiting backend confirmation.",
              element4:
                "Leverage disabled groups during role-based access reviews to reduce per-button overrides.",
            },
            subtitle2: "Developer Notes",
            list2: {
              element1:
                "Communicate why the group is disabled (tooltip/helper).",
              element2:
                "Allow granular overrides only when explicitly required.",
              element3:
                "Expose a single override API for exceptions to avoid prop explosion.",
              element4:
                "Document precedence rules when child-level disables differ from group-level.",
            },
          },
        },
        "button-group-alignment": {
          title: "Button Group Alignment",
          description:
            "Configure the layout direction of buttons using the <b>align</b> prop. Set it to <b>horizontal</b> (default) to arrange buttons side-by-side, or <b>vertical</b> to stack them top-to-bottom. This is useful for adapting button groups to different layout contexts, such as toolbars or form actions.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Layout Strategies",
            list1: {
              element1: "Horizontal for toolbar-like interactions.",
              element2: "Vertical for narrow columns and mobile stacks.",
              element3:
                "Switch alignment responsively for smaller breakpoints to preserve touch targets.",
              element4:
                "Consider grouping alignment with adjacent layout components (inputs, labels) for visual coherence.",
            },
            subtitle2: "Design Considerations",
            list2: {
              element1: "Mirror alignment with surrounding layout flow.",
              element2: "Maintain consistent spacing between grouped items.",
              element3:
                "When stacking vertically, ensure accessible hit area and consistent vertical rhythm.",
              element4:
                "Support reverse ordering for RTL locales and document expected behavior.",
            },
          },
        },
        "button-group-radius": {
          title: "Button Group Radius",
          description:
            "Control the curvature of button edges within the group using the <b>radius</b> prop. Available values include <b>none</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, and <b>full</b>. This allows the group to visually align with the overall interface shape semantics, especially in rounded or sharp UI layouts.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Visual Consistency",
            list1: {
              element1: "Match group radius to global container shape tokens.",
              element2: "Use <b>full</b> for pill-style segmented controls.",
              element3:
                "Apply appropriate clipping rules to avoid adjacent element overlap when using large radii.",
              element4:
                "Ensure consistent radius behavior for first/last children when dynamic children are added/removed.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Avoid mixed radii within a single group.",
              element2:
                "Ensure first/last items visually cap the group correctly.",
              element3:
                "Provide utilities to normalize border-radius when combining with external wrappers.",
              element4:
                "Validate radius combinations visually in both LTR and RTL contexts.",
            },
          },
        },
        "button-group-size": {
          title: "Button Group Size",
          description:
            "The <b>size</b> prop defines the uniform sizing of all buttons within the group. Choose from <b>xsm</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, or <b>xlg</b> to ensure spatial consistency and scalability across various UI breakpoints or interaction densities.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Sync size with nearby inputs and controls.",
              element2: "Use larger sizes for touch-first contexts.",
              element3:
                "Use group sizes to enforce visual parity across dynamic button sets.",
              element4:
                "Prefer size tokens that map directly to spacing and typography scales.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Do not mix sizes inside the same group.",
              element2: "Respect vertical rhythm across stacked groups.",
              element3:
                "Expose size-related CSS variables for consumer overrides when necessary.",
              element4:
                "Document responsive size behavior (e.g., auto-scaling on smaller viewports).",
            },
          },
        },
        "button-group-variant": {
          title: "Button Group Variant",
          description:
            "Utilize the <b>variant</b> prop to apply consistent styling across all grouped buttons. Supported variants include <b>default</b>, <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>error</b>, and <b>warning</b>, offering design cohesion for critical and contextual actions.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Design Consistency",
            list1: {
              element1: "Apply one coherent variant per group.",
              element2: "Use neutral/default for mixed-importance utilities.",
              element3:
                "Avoid variant inheritance ambiguity; document precedence rules for group vs child.",
              element4:
                "Use variant mapping to align with product-level semantic tokens for analytics consistency.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Avoid mixing semantic variants within one group.",
              element2: "Ensure contrast remains accessible on all states.",
              element3:
                "Add visual badges or separators when groups contain a mix of semantic importance to avoid misclicks.",
              element4:
                "Provide clear migration guidance if variant palettes change between versions.",
            },
          },
        },
      },
      card: {
        intro: {
          title: "Card",
          description:
            "Cards are flexible containers used to group related content, actions, and visuals. The AristoByte UI Card components provide a clean, responsive foundation for dashboards, lists, media previews, and more. Designed with composability in mind, they support headers, footers, and custom layouts to adapt to any use case.",
        },
        installation: {
          title: "Installation of Card",
          description:
            "The above command is for individual installation of Card only. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Card",
          description:
            "The Card component is part of the AristoByte UI library—a modular design system built for consistency and scalability across your applications. Use the import below to access a reusable, fully encapsulated UI element that adheres to your design and development standards.",
        },
      },
      spinner: {
        intro: {
          title: "Spinner",
          description:
            "Spinners indicate loading or ongoing processes, keeping users informed while the system completes background tasks.",
        },
        installation: {
          title: "Installation of Spinner",
          description:
            "The above command installs the Spinner component individually. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Spinner",
          description:
            "The Spinner component provides visual feedback for asynchronous actions, improving user awareness of system state. Import it as shown below to seamlessly integrate it into loading workflows:",
        },
        types: {
          title: "Spinner Types",
          description:
            "AristoByte UI offers five spinner types — <b>default</b>, <b>duo</b>, <b>gradient</b>, <b>pulse</b>, and <b>pulse-duo</b>. Each type provides a distinct animation style suited for different loading scenarios, from inline feedback to full-screen blocking loaders.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1:
                "Use simple types for inline indicators; complex for standalone loaders.",
              element2: "Prefer non-blocking spinners within content regions.",
              element3:
                "Choose duo/gradient types for brand-centric hero loaders where motion complements identity.",
              element4:
                "Use pulse types sparingly in high-density pages to avoid visual fatigue.",
            },
            subtitle2: "Performance Considerations",
            list2: {
              element1:
                "Avoid overly decorative types in enterprise workflows.",
              element2:
                "Ensure animation performance stays under 60fps budget.",
              element3:
                "Fallback to static indicators in reduced-motion user settings.",
              element4:
                "Keep DOM footprint minimal for spinner variants used frequently in lists.",
            },
          },
        },
        variants: {
          title: "Spinner Variants",
          description:
            "Spinners can adopt different colors (e.g., <b>default</b>, <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>warning</b>, <b>error</b>) to reflect status or brand semantics during loading phases.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Semantic Mapping",
            list1: {
              element1:
                "Map variant color to the underlying operation's intent.",
              element2: "Use neutral variants for generic background loading.",
              element3:
                "Avoid color semantics that conflict with surrounding alerts or messages.",
              element4:
                "Document variant palette so consumers can choose consistent intent across components.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Maintain contrast against the host surface.",
              element2: "Avoid red unless signaling error-state recovery.",
              element3:
                "Provide tokenized color fallbacks for consumer themes that override core palettes.",
              element4:
                "Test spinner visibility across density and scale settings in OS accessibility panels.",
            },
          },
        },
        sizes: {
          title: "Spinner Sizes",
          description:
            "The Spinner component supports five predefined sizes — <b>xsm</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, and <b>xlg</b> — enabling consistent integration across interface hierarchies. From inline loaders to full-screen indicators, choose the size that best fits the UI context.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use smaller sizes inline with text or icons.",
              element2:
                "Use large/x-large for blocking overlays or empty states.",
              element3:
                "Prefer size tokens aligned to component density metrics to ensure cohesive scaling.",
              element4:
                "Use larger spinners for empty-state placeholders to center user attention.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Keep spinner size proportional to containing control.",
              element2: "Avoid oversized loaders that shift layout.",
              element3:
                "Expose size props rather than hard-coded CSS so consumers can adapt programmatically.",
              element4:
                "Validate spinner sizing on retina and high-DPI displays to prevent pixelation.",
            },
          },
        },
      },
      "message-box": {
        intro: {
          title: "Message Box",
          description:
            "Message Boxes provide contextual system feedback for user actions, conveying information, warnings, errors, or success states with clarity and emphasis.",
        },
        installation: {
          title: "Installation of Message Box",
          description:
            "The above command installs the Message Box component individually. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Message Box",
          description:
            "The Message Box component delivers user-facing alerts with semantic clarity and visual consistency. Import it as shown below to streamline notification delivery in your application:",
        },
        variants: {
          title: "Message Box Variants",
          description:
            "AristoByte UI supports various message box types including <b>info</b>, <b>success</b>, <b>warning</b>, and <b>error</b>. Each type maps to a specific context and visual tone, ensuring users immediately understand the nature of the message.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use semantic variants to match message intent.",
              element2: "Prefer neutral/info for non-blocking notifications.",
              element3:
                "Select success for completed flows and error for actionable failures.",
              element4:
                "Use warning for recoverable states that require user attention but not immediate interruption.",
            },
            subtitle2: "Remediation & UX",
            list2: {
              element1:
                "Do not use success/error for purely informational content.",
              element2: "Keep messages concise with a clear remediation path.",
              element3:
                "Provide clear CTA or link to remediation when the message signals user action.",
              element4:
                "Expose machine-readable codes (data-error-code) to facilitate automated monitoring.",
            },
          },
        },
        types: {
          title: "Message Box Types",
          description:
            "Choose between <b>solid</b>, <b>outline</b>, <b>outline-dashed</b>, <b>no-outline</b> and <b>glowing</b> styles to align with your UI aesthetic and message urgency. Variants control emphasis and contrast for better UX alignment.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Apply",
            list1: {
              element1: "Use solid for blocking/high-emphasis alerts.",
              element2: "Use outline/no-outline for inline, low-noise hints.",
              element3:
                "Prefer dashed outlines for provisional or beta notices to indicate lower fidelity.",
              element4:
                "Use glowing types only when the notification needs to break out of dense UI without modalizing the experience.",
            },
            subtitle2: "Design Considerations",
            list2: {
              element1: "Avoid glowing in high-density enterprise screens.",
              element2: "Ensure outlined types maintain sufficient contrast.",
              element3:
                "Consistently apply padding and margin tokens across types to avoid layout drift.",
              element4:
                "Make sure visual weight of type matches its semantic urgency to avoid false alarms.",
            },
          },
        },
        radius: {
          title: "Message Box Radius",
          description:
            "Control the border curvature of the Message Box using predefined radius values — <b>none</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, and <b>full</b>. This allows for seamless adaptation to different UI aesthetics, whether you're aiming for sharp, modern edges or fully rounded surfaces.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Visual Alignment",
            list1: {
              element1: "Match radius with surrounding card/panel geometry.",
              element2: "Use full for pill-like banners when space allows.",
              element3:
                "Prefer consistent radius tokens across notification stacks to prevent visual clutter.",
              element4:
                "When using full radius, ensure clipping does not hide important message content.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1:
                "Avoid mixing multiple radii within one notification stack.",
              element2: "Respect container clipping for overflowed radii.",
              element3:
                "Test radius combinations on responsive breakpoints to prevent overlap with container edges.",
              element4:
                "Document radius trade-offs for dense dashboards vs marketing surfaces.",
            },
          },
        },
        "without-icon": {
          title: "Message Box Without Icon",
          description:
            "A minimal version of the message box component that omits the icon by default. The <b>withIcon</b> prop is set to <b>false</b> unless explicitly enabled, offering a cleaner layout when visual indicators are unnecessary.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use for low-severity, passive information.",
              element2: "Prefer in dense layouts where space is constrained.",
              element3:
                "Use icon-less variants for compact lists of system messages to reduce visual density.",
              element4:
                "Prefer without-icon in high-volume notification feeds to maintain scanning efficiency.",
            },
            subtitle2: "Content Strategy",
            list2: {
              element1:
                "Ensure copy provides sufficient context without an icon.",
              element2: "Do not remove icons for critical alerts.",
              element3:
                "Add succinct actionable copy or link to compensate for the missing visual cue.",
              element4:
                "Run readability checks on multi-locale content when icons are omitted to ensure clarity.",
            },
          },
        },
      },
      switch: {
        intro: {
          title: "Switch",
          description:
            "Switch toggles are interactive binary controls used for enabling or disabling a specific option. Ideal for settings, preferences, and form controls, the Switch component ensures clear, intuitive state management.",
        },
        installation: {
          title: "Installation of Switch",
          description:
            "The above command installs the Switch component individually. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Switch",
          description:
            "You can import the Switch component either as a standalone module or from the global AristoByteUI package. The import method depends on how your project structure is configured.",
        },
        labeled: {
          title: "Labeled Switch",
          description:
            "Pass a text string using the <b>label</b> prop to display a caption alongside the Switch component. This label improves clarity and accessibility, making it easier for users to understand the function being toggled. It's especially effective in form fields, settings panels, or anywhere context is needed.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Usage Scenarios",
            list1: {
              element1: "Use labels to clarify domain meaning of the toggle.",
              element2: "Localize labels to match app language settings.",
              element3:
                "Prefer concise labels (2-4 words) that map directly to backend fields.",
              element4:
                "When space permits, include a short helper to explain complex toggle behavior.",
            },
            subtitle2: "Accessibility & Implementation",
            list2: {
              element1: "Associate label via <label for> or aria-labelledby.",
              element2: "Keep label copy concise (2-4 words).",
              element3:
                "Ensure label changes are announced by screen readers when state toggles programmatically.",
              element4:
                "Provide test IDs for labels to support UI automation and telemetry correlation.",
            },
          },
        },
        disabled: {
          title: "Disabled",
          description:
            "The <b>disabled</b> prop visually disables the switch, indicating that it cannot be interacted with by the user. While the switch becomes non-clickable, it can still reflect a <b>checked</b> or <b>unchecked</b> state, allowing developers to communicate a specific status that remains static. This is particularly useful in read-only contexts or in UI flows where toggling is conditionally locked, but the user still needs to observe the current value. Disabled switches maintain their configured <b>variant</b>, <b>size</b>, and <b>label</b> alignment.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Use",
            list1: {
              element1: "Reflect permission gating or system-enforced states.",
              element2: "Use when prerequisites are unmet in forms.",
              element3:
                "Use disabled state to indicate server-derived read-only configuration in settings pages.",
              element4:
                "Apply disabled when dependent asynchronous validations are pending to avoid inconsistent toggles.",
            },
            subtitle2: "Developer Guidance",
            list2: {
              element1: "Explain disabled state with helper text or tooltip.",
              element2: "Avoid disabling core settings without rationale.",
              element3:
                "Prefer programmatic reasons (data-disable-reason) over visual-only indicators for maintainability.",
              element4:
                "Do not rely on visual disabled state for security — enforce permission checks server-side.",
            },
          },
        },
        "align-label": {
          title: "Align Label",
          description:
            "The <b>alignLabel</b> prop allows you to control the positioning of the label relative to the switch thumb. Supported values are <b>horizontal</b> and <b>vertical</b>. The default behavior is <b>vertical</b>, placing the label above or below the switch depending on styling. Use <b>horizontal</b> when you want the label to be inline with the switch for compact layouts.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Layout Patterns",
            list1: {
              element1: "Horizontal for dense settings lists or tables.",
              element2: "Vertical for forms and stacked layouts.",
              element3:
                "Use responsive alignment to shift between horizontal/vertical based on available width.",
              element4:
                "Prefer vertical alignment for forms where label wrapping is likely to improve readability.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Ensure click target includes label and control.",
              element2: "Maintain consistent alignment across a section.",
              element3:
                "When aligning horizontally, ensure the label remains accessible via keyboard navigation.",
              element4:
                "Document expected layout fallback for third-party CSS resets that might alter alignment behavior.",
            },
          },
        },
        variants: {
          title: "Switch Variants",
          description:
            "The Switch component supports multiple color variants such as <b>default</b>, <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>error</b>, and <b>warning</b>. These variants reflect the intent of the toggle action and align with your application's color semantics.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Semantic Mapping",
            list1: {
              element1: "Use primary for high-visibility, core settings.",
              element2: "Use success/error for domain-specific semantics.",
              element3:
                "Map variants to backend meaning when toggles correspond to persistent feature flags.",
              element4:
                "Reserve warning colors for toggles that may cause visible UX changes or require confirmation.",
            },
            subtitle2: "Accessibility Notes",
            list2: {
              element1: "Respect contrast and WCAG state colors.",
              element2: "Avoid alarming colors for benign toggles.",
              element3:
                "Ensure variant colors are still distinguishable for color-blind users (use shape + color).",
              element4:
                "Provide tokenized theming for variant overrides so clients can maintain high contrast.",
            },
          },
        },
        sizes: {
          title: "Switch Sizes",
          description:
            "The Switch component comes in five scalable sizes — <b>xsm</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, and <b>xlg</b>. These sizes provide layout flexibility and can be adapted to match form densities, mobile-first designs, or compact UI patterns.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use smaller sizes in dense data tables.",
              element2: "Use large/x-large on mobile-first screens.",
              element3:
                "Select sizes that maintain a minimum thumb grab area for touch devices.",
              element4:
                "Prefer consistent vertical metrics between switches and adjacent inputs for optical alignment.",
            },
            subtitle2: "Developer Tips",
            list2: {
              element1: "Ensure thumb size remains easily grabbable.",
              element2: "Avoid resizing text without adjusting control size.",
              element3:
                "Document how size impacts layout and provide examples for responsive design.",
              element4:
                "Create snapshot tests for each size to catch visual regressions across themes.",
            },
          },
        },
        checked: {
          title: "Initially Checked",
          description:
            "Use the <b>checked</b> prop to define the initial on/off state of the Switch. When set to <b>true</b>, the switch renders in the active (checked) state on initial mount. This prop is ideal for controlled or semi-controlled usage patterns, particularly in form presets and settings UIs.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Default to the most common safe option.",
              element2: "Reflect server-sourced defaults in settings pages.",
              element3:
                "Use <b>checked</b> to mirror persisted user preferences when rendering forms.",
              element4:
                "Avoid pre-checking toggles that result in billing or destructive behavior.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Avoid dark patterns; never pre-enable risky toggles.",
              element2: "Sync initial state with persisted user preferences.",
              element3:
                "Provide explicit documentation for initial checked semantics to prevent integration errors.",
              element4:
                "When migrating defaults, communicate breaking changes in release notes and deprecation paths.",
            },
          },
        },
        controlled: {
          title: "Controlled Switch",
          description:
            "The controlled version of the <b>Switch</b> component offers explicit control over its state using React state management. This pattern ensures that the <b>checked</b> value is fully managed by the parent component via <code>useState</code> and updated through the <b>onChange</b> callback. It's particularly useful when you need to synchronize the switch state with business logic, form handlers, or other UI elements.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Integration Patterns",
            list1: {
              element1: "Coordinate state with forms, stores, or URL params.",
              element2: "Drive from a single source of truth in complex UIs.",
              element3:
                "When integrating with form libraries, map onChange to library adapters to avoid duplicate renders.",
              element4:
                "Use controlled pattern for toggles that affect other components or persist to remote stores.",
            },
            subtitle2: "Developer Notes",
            list2: {
              element1: "Debounce writes if persisting remotely.",
              element2: "Always implement onChange with idempotent handlers.",
              element3:
                "Consider optimistic UI updates with rollback paths for failed persistence.",
              element4:
                "Document expected event payload structure to ensure consistent consumer implementations.",
            },
          },
        },
        "track-icon": {
          title: "Track Icons",
          description:
            "The <b>trackIcon</b> prop enables the display of icons within the switch track itself, offering enhanced visual context for toggled states. You can define icons for both <b>checked</b> and <b>unchecked</b> states by passing a config object like <code>{ checked: IconOn, unchecked: IconOff }</code>. These icons render respectively on the left and right sides of the track. It's optional—providing only one or none is fully supported. This feature is useful for reinforcing switch semantics such as enabling/disabling, visibility toggles, and more.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Design Considerations",
            list1: {
              element1:
                "Use icons to reinforce domain meaning (e.g., eye/eye-off).",
              element2: "Use sparingly to avoid visual noise.",
              element3:
                "Ensure icons are legible across sizes and themes; consider stroke weight consistency.",
              element4:
                "Prefer subtle icons that act as affordances rather than decorative elements.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Keep icons subtle and size-aligned to the track.",
              element2: "Ensure icons remain legible at all sizes.",
              element3:
                "Provide non-icon alternatives for assistive tech consumers (aria-label fallback).",
              element4:
                "Avoid adding heavy SVGs that increase bundle size for frequently-rendered switches.",
            },
          },
        },
        "thumb-icon": {
          title: "Thumb Icon",
          description:
            "The <b>thumbIcon</b> prop allows you to inject a custom icon directly into the switch's thumb element, offering a more expressive and branded interaction model. This prop accepts a single <code>React.ElementType</code> and renders the icon inside the movable thumb regardless of its state. It's ideal for use cases where a consistent icon (e.g., a power symbol, lock, or eye) enhances the user's understanding of the control. If omitted, the thumb renders without any icon by default.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use for strong branding or explicit affordance.",
              element2: "Avoid when minimalism and clarity are preferred.",
              element3:
                "Use for clearly semantic controls like power toggles where icon adds immediate recognition.",
              element4:
                "Avoid for generic settings where icon could reduce readability.",
            },
            subtitle2: "Developer Tips",
            list2: {
              element1: "Keep contrast sufficient against the thumb color.",
              element2: "Do not animate icons independently of the thumb.",
              element3:
                "Provide scalable vector icons to avoid pixelation at large sizes.",
              element4:
                "Document accessibility expectations when thumb icons replace textual cues.",
            },
          },
        },
      },
      radio: {
        intro: {
          title: "Radio",
          description:
            "A component for selecting a single option from a predefined set. <code>Radio</code> and <code>RadioGroup</code> provide a flexible foundation for building accessible, customizable choice interfaces in forms or filters.",
        },
        installation: {
          title: "Installation of Radio",
          description:
            "The above command installs the Radio component individually. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Radio",
          description:
            "You can either import <code>Radio</code> and <code>RadioGroup</code> directly from the package or rely on a global import setup. Both approaches ensure consistent and scoped styling.",
        },
        disabled: {
          title: "Disabled",
          description:
            "When the <b>disabled</b> prop is applied to the <code>RadioGroup</code>, it cascades to all nested <code>Radio</code> components, making them non-interactive. Even in a disabled state, radios can still reflect a <b>checked</b> value, preserving visual selection without allowing user interaction. You may also define <b>disabled</b> at the <code>Radio</code> level for more granular control—individual definitions take precedence.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Scenarios",
            list1: {
              element1: "Lock selection pending validation or permissions.",
              element2: "Prevent changes during in-flight submissions.",
              element3:
                "Use group-level disable to reflect read-only server side settings consistently.",
              element4:
                "Disable radios when subsequent steps depend on a confirmed upstream state.",
            },
            subtitle2: "Developer Guidance",
            list2: {
              element1: "Explain disabled state via helper text.",
              element2: "Keep visual distinction clear from unchecked state.",
              element3:
                "Provide ARIA roles and descriptions to clarify disabled semantics for assistive tech.",
              element4:
                "Document how overrides behave when both group and individual radios are marked disabled.",
            },
          },
        },
        sizes: {
          title: "Sizes",
          description:
            "The <b>size</b> prop defines the scale of the radio control and its label. Available options include <b>xsm</b>, <b>sm</b>, <b>md</b>, <b>lg</b>, and <b>xlg</b>, giving developers flexibility to match component sizing with typography, spacing, and layout needs. The default size is <b>md</b>. This prop can be defined on both <code>RadioGroup</code> and <code>Radio</code>, with the latter taking priority when both are present.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Layout Guidance",
            list1: {
              element1:
                "Use small for dense filters; large for touch-first UIs.",
              element2: "Scale with type ramp to maintain rhythm.",
              element3:
                "Prefer nominal sizes that map to global type-scale tokens for predictable layout.",
              element4:
                "Avoid using extremes simultaneously in the same form to prevent visual dissonance.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Ensure labels remain readable at smaller sizes.",
              element2: "Maintain a11y hit area even when visually compact.",
              element3:
                "Document how size interacts with label wrapping and alignment in responsive contexts.",
              element4:
                "Include unit tests to assert the hit-target minimum dimensions across sizes.",
            },
          },
        },
        variants: {
          title: "Variants",
          description:
            "The <b>variant</b> prop determines the visual styling of the radio control, allowing it to adapt to various semantic contexts or UI themes. Available values include <b>default</b>, <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>error</b>, and <b>warning</b>. These variants typically map to predefined color tokens and help ensure design consistency across components. If not defined, the <b>default</b> style is applied. You may pass this prop to <code>RadioGroup</code> or to individual <code>Radio</code> components, where the latter will override inherited group values.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Semantic Use",
            list1: {
              element1: "Use primary for key decision points.",
              element2: "Use default/neutral for low-stakes choices.",
              element3:
                "Use variants to visually group related options that map to different operational modes.",
              element4:
                "Avoid semantic variants for purely ornamental radios to prevent misuse by consumers.",
            },
            subtitle2: "Design Notes",
            list2: {
              element1: "Keep variant consistent across a single group.",
              element2: "Ensure selected state contrast is unambiguous.",
              element3:
                "Provide a token map document for variant-to-token relationships for integrators.",
              element4:
                "Test variant rendering across brand themes to catch token overrides that reduce contrast.",
            },
          },
        },
        appearance: {
          title: "Appearance",
          description:
            "The <b>appearance</b> prop defines the visual structure of the radio's outline and its interaction state feedback. Available values include <b>solid</b>, <b>outline</b>, <b>outline-dashed</b>, <b>no-outline</b>, and <b>glowing</b>. By default, the radio adopts the <b>outline</b> appearance. Each variant provides a distinct visual tone—ranging from minimalist (<b>no-outline</b>) to expressive (<b>glowing</b>)—allowing precise alignment with your product's design language. This prop is supported on both <code>RadioGroup</code> and <code>Radio</code>; however, direct <code>Radio</code> definitions take precedence.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Apply",
            list1: {
              element1: "Use outline for most enterprise use cases.",
              element2: "Use solid for high-emphasis, limited option sets.",
              element3:
                "Reserve <b>glowing</b> appearance for focused callouts or onboarding flows.",
              element4:
                "Choose no-outline when embedding radios into fully illustrated or branded surfaces.",
            },
            subtitle2: "Design Best Practices",
            list2: {
              element1: "Avoid glowing in dense data surfaces.",
              element2: "Ensure dashed outlines remain visible at small sizes.",
              element3:
                "Document visual hierarchy for appearance options to help consumers choose appropriately.",
              element4:
                "Ensure appearance options have consistent hover/focus interactions to avoid surprises.",
            },
          },
        },
        "highlight-label": {
          title: "Highlight Label",
          description:
            "Enables the label to inherit the active <b>variant</b> color when <b>highlightLabel</b> is set to <b>true</b>. This enhances visual association between the label and the selected theme. When <b>false</b> (default), the label color remains neutral or white. The prop can be used on <code>RadioGroup</code> to apply it broadly, but <code>Radio</code>-level values override group-level settings.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "When to Use",
            list1: {
              element1: "Use to emphasize selected options in short lists.",
              element2: "Avoid in long lists to reduce visual noise.",
              element3:
                "Use highlightLabel for compact decision UIs where color reinforces selection.",
              element4:
                "Avoid highlightLabel in dense dashboards where color overload reduces scanability.",
            },
            subtitle2: "Design Notes",
            list2: {
              element1: "Maintain accessible color contrast on labels.",
              element2:
                "Ensure highlight doesn't imply clickability when disabled.",
              element3:
                "Provide option to programmatically toggle highlight for testing visual regressions.",
              element4:
                "Document highlight behavior for both group and individual radio overrides.",
            },
          },
        },
        "radio-group-align": {
          title: "Align Radios",
          description:
            "The <b>align</b> prop controls the directional layout of the <code>Radio</code> components within the <code>RadioGroup</code>. By default, radios are stacked <b>vertical</b>, but you can switch to a <b>horizontal</b> layout for more compact or inline presentations. Alignment can also be defined per <code>Radio</code> component, which overrides the group alignment if both are defined.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Layout Patterns",
            list1: {
              element1: "Horizontal for up to 3-4 short options.",
              element2: "Vertical for long labels or many options.",
              element3:
                "When horizontal wrapping occurs, ensure each radio remains a separate focus target.",
              element4:
                "Prefer vertical stacking for accessibility when option labels are long or contain explanatory copy.",
            },
            subtitle2: "Best Practices",
            list2: {
              element1: "Maintain consistent spacing between items.",
              element2: "Wrap long labels; don't shrink tap targets.",
              element3:
                "Provide responsive examples in docs to show how alignment adapts across breakpoints.",
              element4:
                "Consider alignment interactions with flex/grid containers to prevent overflow.",
            },
          },
        },
        "align-label": {
          title: "Align Label",
          description:
            "The <b>alignLabel</b> prop allows fine-tuned control over the label's position relative to the radio control. It accepts <b>top</b>, <b>right</b>, <b>bottom</b>, or <b>left</b>, with <b>bottom</b> being the default. This prop can be applied to both <code>Radio</code> and <code>RadioGroup</code>, but individual <code>Radio</code> components take precedence when both are defined.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Layout Guidance",
            list1: {
              element1: "Left/right for compact, inline content.",
              element2: "Top/bottom for forms with stacked fields.",
              element3:
                "Use top alignment for prominent labels that should read before the control.",
              element4:
                "Use left/right alignment for multi-column forms to save vertical space.",
            },
            subtitle2: "Developer Notes",
            list2: {
              element1: "Ensure label remains clickable with the control.",
              element2: "Keep alignment consistent across a group.",
              element3:
                "Account for different languages and label lengths when choosing alignment to avoid overflow.",
              element4:
                "Provide a11y examples showing label association across alignment permutations.",
            },
          },
        },
        controlled: {
          title: "Controlled Radios",
          description:
            "A controlled <b>RadioGroup</b> allows full external control over the selected value using React state. By passing a dynamic <code>value</code> and <code>onChange</code> handler—typically derived from <code>useState</code>—you ensure the radio selection is synchronized with the component's state lifecycle. This pattern is ideal for form integrations, live previews, and data-bound interfaces where UI must reflect application state in real time.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Integration Patterns",
            list1: {
              element1: "Sync with form libs (e.g., RHF, Formik).",
              element2: "Persist selected value to URL or store as needed.",
              element3:
                "Use controlled pattern to coordinate dependent form fields and derived state.",
              element4:
                "Avoid mixing uncontrolled radios in a controlled group to prevent unpredictable behavior.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Treat value as immutable; update via onChange only.",
              element2: "Keep controlled and uncontrolled patterns separate.",
              element3:
                "Provide clear example code snippets for controlled/uncontrolled patterns in docs.",
              element4:
                "Debounce heavy updates triggered by radio changes to avoid thrashing connected systems.",
            },
          },
        },
      },
      dropdown: {
        intro: {
          title: "Dropdown",
          description:
            "Dropdowns enable users to select a single option from a contextual list. It's a compact, flexible UI pattern ideal for filters, forms, and segmented controls.",
        },
        installation: {
          title: "Installation of Dropdown",
          description:
            "The above command is for individual installation of Dropdown only. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Dropdown",
          description:
            "The Dropdown component provides a minimal yet accessible selection UI for various use cases. It supports dynamic options, disabled states, and custom styling. Import it as shown below to enrich your data selection flows:",
        },
        disabled: {
          title: "Disabled",
          description:
            "Demonstrates a <b>Dropdown</b> component in a <b>disabled</b> state. All options and interactions are inactive, ensuring that users cannot modify the selection.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Use Cases",
            list1: {
              element1: "Freeze selection while dependencies load or validate.",
              element2: "Gate access when user lacks required permissions.",
              element3:
                "Disable when server-side flags indicate the selection is currently immutable.",
              element4:
                "Use disabled dropdowns as placeholders while remote option lists are being fetched.",
            },
            subtitle2: "Developer Best Practices",
            list2: {
              element1: "Explain disabled reason via tooltip/help text.",
              element2: "Maintain readable value even when disabled.",
              element3:
                "Preserve semantic markup (select/option) for accessibility even when visually disabled.",
              element4:
                "Document keyboard behavior and focus management for disabled dropdowns.",
            },
          },
        },
        appearance: {
          title: "Appearance",
          description:
            "Illustrates all available <b>Dropdown</b> <b>appearances</b> — <b>solid</b>, <b>glowing</b>, <b>outline</b>, <b>outline-dashed</b>, <b>no-outline</b> — across variants (<b>default</b>, <b>primary</b>, <b>secondary</b>, <b>success</b>, <b>error</b>, <b>warning</b>). Useful for visual reference and styling consistency. Use <b>variant</b> to convey semantic intent, while <b>appearance</b> controls decorative rendering.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Design Options",
            list1: {
              element1:
                "Use outline for standard forms; solid for high-contrast UIs.",
              element2:
                "Use no-outline in minimal surfaces with strong backgrounds.",
              element3:
                "Choose glowing only when the dropdown needs to attract attention in onboarding or spotlight flows.",
              element4:
                "Prefer dashed outlines for experimental UI patterns to indicate tentative styling.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1: "Keep placeholder text distinct from selected value.",
              element2: "Ensure focus/hover states are clearly visible.",
              element3:
                "Provide accessible labeling and ensure appearance changes do not remove focus indicators.",
              element4:
                "Test appearance variants across different density themes to ensure consistent spacing and legibility.",
            },
          },
        },
      },
    },
    presets: {
      "social-media-card": {
        intro: {
          title: "Social Media Card",
          description:
            "The <b>Social Media Card</b> preset provides a modular content block for displaying user profiles, posts, or activity snippets. Designed for engagement-driven UIs, it supports avatars, metadata, and action buttons to replicate modern social feed interactions.",
        },
        installation: {
          title: "Installation of Social Media Card",
          description:
            "Install the <b>Social Media Card</b> preset individually using the command above. You may skip this step if <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Social Media Card",
          description:
            "Import the <b>Social Media Card</b> from the AristoByte UI package to rapidly integrate feed-like layouts into your application. Its composable design allows easy extension with comments, likes, and sharing controls.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Demonstrates the <b>SocialMediaCard</b> in a <b>disabled</b> state. Interactions such as the action <b>button</b> are inactive, preventing any user actions.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Context",
            list1: {
              element1:
                "Disable interactive affordances when user actions are blocked by account status or rate-limits.",
              element2:
                "Use disabled state while remote content (comments/likes) is syncing to avoid inconsistent counts.",
              element3:
                "Suppress share/like CTA when privacy or consent flags are unresolved for the content owner.",
              element4:
                "Temporarily disable actions during moderation or content review windows to prevent premature engagement.",
            },
            subtitle2: "UX & Developer Notes",
            list2: {
              element1:
                "Render explanatory microcopy or tooltip to communicate why actions are disabled.",
              element2:
                "Keep visible metadata (likes, timestamp) readable even when interactive controls are disabled.",
              element3:
                "Provide a programmatic reason code (data-disabled-reason) for telemetry and automated tests.",
              element4:
                "Ensure disabled styling is keyboard- and screen-reader-friendly; maintain semantic DOM order.",
            },
          },
        },
      },
      "music-player": {
        intro: {
          title: "Music Player",
          description:
            "The <b>Music Player</b> preset delivers an embedded audio playback interface with controls for play, pause, skip, and volume. Tailored for media-centric applications, it ensures accessibility and responsive interaction patterns.",
        },
        installation: {
          title: "Installation of Music Player",
          description:
            "Install the <b>Music Player</b> preset individually. This step can be skipped if <b>@aristobyte-ui</b> is already available globally.",
        },
        import: {
          title: "Import Music Player",
          description:
            "Bring the <b>Music Player</b> component into your project to offer users direct control over audio content. The preset ships with adaptive styling for mobile and desktop breakpoints.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Shows the <b>Music Player</b> when playback controls are disabled — e.g., due to lack of license, offline state, or missing media — preventing playback interactions.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Playback Constraints",
            list1: {
              element1:
                "Disable controls when DRM/licensing checks fail or content is region-restricted.",
              element2:
                "Disable playback during network offline states or when required assets are unavailable.",
              element3:
                "Lock skip/repeat controls when a playlist is being re-ordered or persisted to avoid state race conditions.",
              element4:
                "Disable advanced features (equalizer, effects) when device capabilities don't support them.",
            },
            subtitle2: "Accessibility & Resilience",
            list2: {
              element1:
                "Provide clear fallback messaging (e.g., Offline — Playback unavailable) when disabled.",
              element2:
                "Ensure keyboard focus does not get trapped on disabled controls but remains discoverable for status announcements.",
              element3:
                "Expose programmatic flags for remote orchestration (e.g., telemetry that indicates why playback is disabled).",
              element4:
                "Design visual hierarchy so disabled player still surfaces critical metadata (track title, progress) for user context.",
            },
          },
        },
      },
      "statistics-cards": {
        intro: {
          title: "Statistics Cards",
          description:
            "The <b>Statistics Cards</b> preset enables at-a-glance metrics display. Ideal for dashboards and analytics, each card showcases key KPIs with clear typography, icons, and contextual coloring.",
        },
        installation: {
          title: "Installation of Statistics Cards",
          description:
            "Install the <b>Statistics Cards</b> preset individually if not already included in the global <b>@aristobyte-ui</b> package.",
        },
        import: {
          title: "Import Statistics Cards",
          description:
            "Import <b>Statistics Cards</b> into your dashboard to provide users with concise, visually distinct data summaries. Cards can be customized with icons, variants, and sizing props.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Displays a <b>Statistics Card</b> in a <b>disabled</b> state when metrics are incomplete, loading, or when access to the dataset is restricted.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Data Integrity",
            list1: {
              element1:
                "Disable interactive drill-ins when underlying data is stale or being re-aggregated.",
              element2:
                "Disable export/share buttons until server-side permissions are validated.",
              element3:
                "Show skeletons or placeholders when partial data prevents meaningful interaction.",
              element4:
                "Avoid enabling KPI-linked actions until dependent query jobs complete to prevent misleading insights.",
            },
            subtitle2: "Presentation & Implementation",
            list2: {
              element1:
                "Communicate the data state (stale/loading/unauthorized) with clear messaging near the metric.",
              element2:
                "Use subdued styling while keeping headline values legible for monitoring scenarios.",
              element3:
                "Provide hooks/events that allow consumers to subscribe to data readiness changes to re-enable interactions.",
              element4:
                "Log disabled-state reasons for analytics to understand frequency of unavailable metrics.",
            },
          },
        },
      },
      "settings-panel": {
        intro: {
          title: "Settings Panel",
          description:
            "The <b>Settings Panel</b> preset organizes configuration options into a clean, intuitive interface. Perfect for account preferences, system settings, or feature toggles.",
        },
        installation: {
          title: "Installation of Settings Panel",
          description:
            "Install the <b>Settings Panel</b> preset individually. Skip this step if <b>@aristobyte-ui</b> is installed globally.",
        },
        import: {
          title: "Import Settings Panel",
          description:
            "Import the <b>Settings Panel</b> into your application to centralize user configuration. It supports nested controls, switches, and contextual grouping for clarity.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Illustrates the <b>Settings Panel</b> in a disabled or read-only mode when configuration changes are not permitted due to role restrictions, maintenance, or pending policy approvals.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Governance Scenarios",
            list1: {
              element1:
                "Disable whole sections when user lacks role-based permissions or when admin overrides are in effect.",
              element2:
                "Temporarily lock settings during system maintenance windows to avoid partial writes.",
              element3:
                "Mark settings read-only when policies or compliance checks require audit before changes.",
              element4:
                "Disable dependent controls if higher-level toggles are turned off to avoid invalid configurations.",
            },
            subtitle2: "User Communication",
            list2: {
              element1:
                "Provide inline explanations and links to docs or support when settings are disabled for governance reasons.",
              element2:
                "Allow a clear call-to-action (request access) when appropriate, instead of silent disabling.",
              element3:
                "Emit accessibility-friendly notifications describing why the panel is read-only.",
              element4:
                "Maintain consistent API behavior: UI disabled state should mirror server-side permission checks.",
            },
          },
        },
      },
      "action-buttons": {
        intro: {
          title: "Action Buttons",
          description:
            "The <b>Action Buttons</b> preset provides a collection of quick-access controls designed for contextual actions. Ideal for toolbars, card footers, and floating action layouts.",
        },
        installation: {
          title: "Installation of Action Buttons",
          description:
            "Install the <b>Action Buttons</b> preset individually. You may skip if <b>@aristobyte-ui</b> is already part of your project.",
        },
        import: {
          title: "Import Action Buttons",
          description:
            "Import <b>Action Buttons</b> into your UI to streamline repetitive tasks and enable consistent call-to-action placement. Compatible with all button variants and appearances.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Shows the <b>Action Buttons</b> preset where quick actions are disabled due to context (e.g., selection absent, operation pending, or insufficient permissions).",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Contextual Disabling",
            list1: {
              element1:
                "Disable actions that require a selection when nothing is selected to prevent no-op operations.",
              element2:
                "Disable shortcuts during modal or global blocking states to prevent unexpected behavior.",
              element3:
                "Disable actions while related async tasks (e.g., batch apply) are in-flight to maintain consistency.",
              element4:
                "Use disabled variant for deprecated actions that will be removed in future releases.",
            },
            subtitle2: "Developer & UX Tips",
            list2: {
              element1:
                "Surface helper text or inline affordances to explain disabled state (e.g., 'Select at least one item').",
              element2:
                "Keep keyboard access predictable; do not remove focusability unless completely inert.",
              element3:
                "Provide a single API to toggle action availability to simplify state management.",
              element4:
                "Log user attempts on disabled actions for UX diagnostics to identify confusion hotspots.",
            },
          },
        },
      },
      "status-indicators": {
        intro: {
          title: "Status Indicators",
          description:
            "The <b>Status Indicators</b> preset provides lightweight visual signals to communicate state, availability, or progress. Commonly used in dashboards, chat presence, or device monitors.",
        },
        installation: {
          title: "Installation of Status Indicators",
          description:
            "Install the <b>Status Indicators</b> preset individually if needed. Otherwise, use the globally available version from <b>@aristobyte-ui</b>.",
        },
        import: {
          title: "Import Status Indicators",
          description:
            "Import <b>Status Indicators</b> to enrich your UI with semantic feedback. Supports color variants and size scaling for adaptive integration.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Depicts <b>Status Indicators</b> in a disabled or neutralized state when telemetry is absent, stale, or when the monitored resource is offline.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Telemetry & Signal Validity",
            list1: {
              element1:
                "Render disabled indicator when device/resource reports no telemetry or returns 404/timeout.",
              element2:
                "Use disabled state for indicators when user has no permission to view live status.",
              element3:
                "Neutralize indicators during maintenance windows to avoid alert fatigue.",
              element4:
                "Avoid showing critical color states when signal is unverified; prefer a disabled/unknown state.",
            },
            subtitle2: "Implementation Notes",
            list2: {
              element1:
                "Keep the visual meaning explicit (e.g., an 'unknown' label) rather than silently dimming the indicator.",
              element2:
                "Expose hooks for consumers to supply alternative data or refresh triggers when indicators are disabled.",
              element3:
                "Ensure screen readers announce status as 'unavailable' or 'offline' to aid monitoring workflows.",
              element4:
                "Aggregate disabled-state metrics centrally so SRE/UX teams can identify systemic observability gaps.",
            },
          },
        },
      },
      "navigation-pills": {
        intro: {
          title: "Navigation Pills",
          description:
            "The <b>Navigation Pills</b> preset offers a compact tab-like navigation system styled as rounded pills. It is ideal for segmenting content categories or toggling views.",
        },
        installation: {
          title: "Installation of Navigation Pills",
          description:
            "Install the <b>Navigation Pills</b> preset individually. Skip if <b>@aristobyte-ui</b> is already available globally.",
        },
        import: {
          title: "Import Navigation Pills",
          description:
            "Import <b>Navigation Pills</b> to enable users to switch between grouped sections. Variants allow semantic styling and highlight current selection.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Shows <b>Navigation Pills</b> in a disabled state when navigation targets are not available, the user lacks permissions, or the view is temporarily locked.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Navigation Constraints",
            list1: {
              element1:
                "Disable pills for routes that are not yet released or are behind feature flags.",
              element2:
                "Disable navigation when prerequisites (e.g., onboarding steps) are incomplete.",
              element3:
                "Use disabled pills to surface roadmap items without allowing navigation yet.",
              element4:
                "Avoid disabling the currently active pill; instead disable only non-applicable targets.",
            },
            subtitle2: "Accessibility & Messaging",
            list2: {
              element1:
                "Provide accessible names and a tooltip explaining why a pill is disabled (e.g., 'Requires Pro plan').",
              element2:
                "Maintain focusability semantics: disabled pills should not receive interactive focus but remain discoverable.",
              element3:
                "Consider progressive disclosure: enable a read-only preview when full navigation is disabled.",
              element4:
                "Instrument disabled pill clicks to measure user intent and prioritize unblock workflows.",
            },
          },
        },
      },
      "quick-actions": {
        intro: {
          title: "Quick Actions",
          description:
            "The <b>Quick Actions</b> preset consolidates a set of commonly performed tasks into an easily accessible UI cluster. Perfect for contextual shortcuts in productivity tools.",
        },
        installation: {
          title: "Installation of Quick Actions",
          description:
            "Install the <b>Quick Actions</b> preset individually, unless already included via the global <b>@aristobyte-ui</b> package.",
        },
        import: {
          title: "Import Quick Actions",
          description:
            "Import <b>Quick Actions</b> to provide users with rapid entry points to frequent workflows. Supports icons, tooltips, and grouped layouts.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Represents <b>Quick Actions</b> when shortcuts are disabled due to context, permission constraints, or when an action is already in progress.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Operational Context",
            list1: {
              element1:
                "Disable quick actions if prerequisites (selection, permissions) are not satisfied.",
              element2:
                "Throttle or disable quick actions when server-side rate limits are exceeded.",
              element3:
                "Disable actions that would conflict with in-progress background jobs to prevent duplicates.",
              element4:
                "Use disabled variants when quick actions are deprecated pending migration.",
            },
            subtitle2: "Developer Guidance",
            list2: {
              element1:
                "Show contextual helper copy explaining how to enable the quick action (e.g., 'Select a file to enable').",
              element2:
                "Keep the visual affordance consistent so users understand which actions are temporarily unavailable.",
              element3:
                "Provide an API hook to surface enablement suggestions or links to relevant settings.",
              element4:
                "Log attempted uses of disabled quick actions to guide UX improvements and feature prioritization.",
            },
          },
        },
      },
      "weather-widget": {
        intro: {
          title: "Weather Widget",
          description:
            "The <b>Weather Widget</b> preset surfaces real-time weather insights in a compact, card-based format. It integrates temperature, condition icons, and location context.",
        },
        installation: {
          title: "Installation of Weather Widget",
          description:
            "Install the <b>Weather Widget</b> preset individually, unless <b>@aristobyte-ui</b> is already installed globally.",
        },
        import: {
          title: "Import Weather Widget",
          description:
            "Import <b>Weather Widget</b> into your application to provide environmental context. Supports location-based customization and unit switching.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Displays the <b>Weather Widget</b> in a disabled state when forecast data is unavailable, location permissions are denied, or rate limits are reached.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "Data Availability",
            list1: {
              element1:
                "Disable widget when third-party weather APIs return errors or when CORS/credential issues occur.",
              element2:
                "Disable when geolocation permission is denied and no fallback location is provided.",
              element3:
                "Use disabled state if forecast refresh fails repeatedly to prevent stale displays.",
              element4:
                "Avoid showing critical weather alerts when widget is disabled; surface system-level alerts instead.",
            },
            subtitle2: "User Experience",
            list2: {
              element1:
                "Provide a clear call-to-action to re-enable (e.g., 'Enable location' or 'Retry').",
              element2:
                "Show concise placeholder data (e.g., 'Data unavailable') rather than blank space.",
              element3:
                "Allow manual location input as an alternative to geolocation for re-enablement.",
              element4:
                "Record disablement reasons for analytics to monitor API reliability and user opt-out rates.",
            },
          },
        },
      },
      "notification-cards": {
        intro: {
          title: "Notification Cards",
          description:
            "The <b>Notification Cards</b> preset provides structured alert blocks for delivering contextual updates. Perfect for activity feeds, dashboards, or inbox-like UIs.",
        },
        installation: {
          title: "Installation of Notification Cards",
          description:
            "Install the <b>Notification Cards</b> preset individually. Skip this step if <b>@aristobyte-ui</b> is globally available.",
        },
        import: {
          title: "Import Notification Cards",
          description:
            "Import <b>Notification Cards</b> to surface time-sensitive messages with consistent styling and hierarchy. Configurable with icons and action buttons.",
        },
        disabled: {
          title: "Disabled",
          description:
            "Renders <b>Notification Cards</b> in a disabled or muted state when actions (acknowledge, snooze, open) are not available due to policy, rate-limits, or remote state.",
          guidelines: {
            title: "Guidelines",
            subtitle1: "State Management",
            list1: {
              element1:
                "Disable notification actions when messages are archived or when the server indicates read-only mode.",
              element2:
                "Mute interactive controls during bulk operations to avoid partial updates.",
              element3:
                "Disable actions for notifications that are pending moderation or legal review.",
              element4:
                "Temporarily disable action buttons when notification payloads are malformed to avoid errors.",
            },
            subtitle2: "UX & Instrumentation",
            list2: {
              element1:
                "Show a succinct reason for disabled actions (e.g., 'Action unavailable — moderation in progress').",
              element2:
                "Maintain the ability to view notification details even when actions are disabled to preserve context.",
              element3:
                "Expose telemetry for disabled action attempts to identify friction points and policy impacts.",
              element4:
                "Gracefully degrade available controls and provide alternative workflows when primary actions are disabled.",
            },
          },
        },
      },
    },
  },
};
